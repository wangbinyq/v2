# Miniflux v2 项目架构分析

## 目录
1. [项目概述](#项目概述)
2. [技术栈](#技术栈)
3. [项目结构](#项目结构)
4. [核心架构](#核心架构)
5. [数据模型](#数据模型)
6. [API 设计](#api-设计)
7. [关键实现细节](#关键实现细节)
8. [部署方式](#部署方式)
9. [构建类似 Golang Web 项目的参考](#构建类似-golang-web-项目的参考)

---

## 项目概述

**Miniflux** 是一个极简、高效的 RSS 阅读器，采用 Go 语言开发。它的设计哲学是简单、快速、轻量级，易于安装和部署。

### 核心特性
- 支持多种 Feed 格式（Atom 0.3/1.0, RSS 1.0/2.0, JSON Feed）
- OPML 导入/导出
- 全文搜索（基于 PostgreSQL）
- 20+ 种语言支持
- 隐私保护（移除跟踪器、清理 URL 参数）
- 25+ 第三方服务集成
- REST API 支持
- 多种认证方式（本地、OAuth2、WebAuthn）
- 响应式 Web UI

### 项目规模
- 总代码行数：约 34,000 行 Go 代码
- 内部模块：27 个
- Feed 解析器：93 个文件
- 第三方集成：30+ 个服务

---

## 技术栈

### 后端技术
- **语言**: Go 1.24+
- **数据库**: PostgreSQL（唯一支持的数据库）
- **HTTP 路由**: Gorilla Mux
- **认证**: 
  - WebAuthn (go-webauthn)
  - OAuth2 (golang.org/x/oauth2)
  - OpenID Connect (coreos/go-oidc)
- **监控**: Prometheus (prometheus/client_golang)
- **HTML 解析**: goquery
- **压缩**: Brotli
- **最小化**: tdewolff/minify

### 前端技术
- 原生 JavaScript（无框架）
- 嵌入式 CSS
- Go embed 包打包静态资源

### 部署技术
- 单一静态二进制文件
- Docker 支持（多架构）
- Systemd 集成
- 自动 HTTPS（Let's Encrypt）

---

## 项目结构

```
miniflux/
├── main.go                     # 程序入口
├── go.mod                      # Go 模块依赖
├── Makefile                    # 构建脚本
├── client/                     # Go 客户端库
├── contrib/                    # 贡献工具和配置
├── packaging/                  # 打包配置（Docker, RPM, Debian）
└── internal/                   # 内部包（不对外暴露）
    ├── api/                    # REST API 实现
    ├── cli/                    # 命令行接口
    ├── config/                 # 配置管理
    ├── crypto/                 # 加密工具
    ├── database/               # 数据库迁移和连接
    ├── fever/                  # Fever API 实现
    ├── googlereader/           # Google Reader API 实现
    ├── http/                   # HTTP 服务器和中间件
    │   ├── cookie/            # Cookie 处理
    │   ├── request/           # 请求处理
    │   ├── response/          # 响应处理
    │   ├── route/             # 路由辅助
    │   └── server/            # HTTP 服务器
    ├── integration/            # 第三方服务集成（30+ 个）
    ├── locale/                 # 国际化翻译
    ├── mediaproxy/            # 媒体代理
    ├── metric/                # Prometheus 指标
    ├── model/                 # 数据模型
    ├── oauth2/                # OAuth2 实现
    ├── proxyrotator/          # 代理轮换
    ├── reader/                # Feed 阅读器核心
    │   ├── atom/             # Atom feed 解析
    │   ├── rss/              # RSS feed 解析
    │   ├── json/             # JSON feed 解析
    │   ├── opml/             # OPML 处理
    │   ├── parser/           # 统一解析器
    │   ├── fetcher/          # Feed 获取
    │   ├── processor/        # Feed 处理
    │   ├── sanitizer/        # 内容清理
    │   ├── scraper/          # 内容抓取
    │   ├── rewrite/          # 内容重写规则
    │   └── readability/      # 可读性提取
    ├── storage/               # 数据访问层
    ├── systemd/               # Systemd 集成
    ├── template/              # HTML 模板
    ├── ui/                    # Web UI 控制器
    │   ├── form/             # 表单处理
    │   ├── session/          # 会话管理
    │   ├── static/           # 静态资源
    │   └── view/             # 视图模板
    ├── urllib/                # URL 工具
    ├── validator/             # 验证器
    ├── version/               # 版本信息
    └── worker/                # 后台任务工作池
```

---

## 核心架构

### 1. 分层架构

Miniflux 采用经典的分层架构模式：

```
┌─────────────────────────────────────────┐
│          CLI / Entry Point              │
│           (main.go, cli/)               │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│      HTTP Server & Routing Layer        │
│   (http/server/, api/, ui/, fever/)     │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│        Business Logic Layer             │
│  (reader/, worker/, integration/)       │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│       Data Access Layer (Storage)       │
│            (storage/)                   │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│          Database (PostgreSQL)          │
└─────────────────────────────────────────┘
```

### 2. 核心组件说明

#### 2.1 CLI 层 (internal/cli/)
- **职责**: 命令行参数解析、启动守护进程
- **关键文件**:
  - `cli.go`: 命令行参数处理
  - `daemon.go`: 启动 HTTP 服务器和调度器
  - `create_admin.go`: 创建管理员用户
  - `health_check.go`: 健康检查
  - `refresh_feeds.go`: 手动刷新 feeds

#### 2.2 HTTP 服务器层 (internal/http/server/)
- **职责**: HTTP 请求处理、中间件、路由
- **关键特性**:
  - 支持多监听地址（TCP、Unix Socket、Systemd Socket）
  - 自动 HTTPS（Let's Encrypt）
  - TLS 支持
  - 健康检查端点（/healthz, /readyz）
  - Prometheus 指标端点（/metrics）
  
**主要中间件**:
```go
// middleware.go
- 日志记录
- 认证检查
- CORS 处理
- 压缩（Brotli）
- 安全头设置
```

#### 2.3 API 层 (internal/api/)
REST API 实现，遵循 RESTful 设计：

```go
// 路由前缀: /v1
// 认证方式: API Key 或 Basic Auth

主要端点：
- /v1/users                    # 用户管理
- /v1/categories              # 分类管理
- /v1/feeds                   # Feed 管理
- /v1/entries                 # 条目管理
- /v1/import                  # OPML 导入
- /v1/export                  # OPML 导出
```

#### 2.4 UI 层 (internal/ui/)
Web UI 控制器，采用服务端渲染：

```go
// 80+ 个控制器文件，每个处理特定功能
// 示例：
- category_entries.go         # 分类条目列表
- feed_edit.go                # Feed 编辑
- entry_read.go               # 标记已读
- subscription_submit.go      # 订阅提交
```

#### 2.5 Feed 阅读器 (internal/reader/)
核心业务逻辑，负责 Feed 解析和处理：

```
reader/
├── parser/         # 统一解析接口
├── atom/          # Atom 格式解析
├── rss/           # RSS 格式解析
├── json/          # JSON Feed 解析
├── fetcher/       # HTTP 获取（支持代理、自定义 UA）
├── processor/     # 内容处理（去重、清理）
├── sanitizer/     # HTML 清理（XSS 防护）
├── scraper/       # 全文抓取
├── rewrite/       # 内容重写规则
└── readability/   # 可读性提取算法
```

#### 2.6 存储层 (internal/storage/)
数据访问层，封装所有数据库操作：

```go
// storage.go
type Storage struct {
    db *sql.DB
}

// 主要方法示例：
- GetUser(userID int64) (*model.User, error)
- CreateFeed(feed *model.Feed) error
- GetUnreadEntries(userID int64) (model.Entries, error)
- UpdateEntry(entry *model.Entry) error
```

**特点**:
- 不使用 ORM
- 原生 SQL 查询
- 事务支持
- 连接池管理

#### 2.7 后台工作池 (internal/worker/)
异步任务处理：

```go
type Pool struct {
    queue chan *model.Job
}

// 支持的任务：
- 刷新 Feed
- 清理旧条目
- 发送集成通知
```

#### 2.8 数据库迁移 (internal/database/)
版本化数据库 schema 管理：

```go
// migrations.go
var migrations = []func(*sql.Tx) error{
    // 每个函数代表一个迁移版本
}

// 自动追踪版本
// 支持回滚保护
```

---

## 数据模型

### 核心实体

#### User（用户）
```go
type User struct {
    ID                  int64
    Username            string
    Password            string      // bcrypt 哈希
    IsAdmin             bool
    Theme               string
    Language            string
    Timezone            string
    EntryDirection      string
    EntryOrder          string
    EntriesPerPage      int
    KeyboardShortcuts   bool
    // ... 30+ 个配置字段
}
```

#### Feed（订阅源）
```go
type Feed struct {
    ID                    int64
    UserID                int64
    FeedURL               string
    SiteURL               string
    Title                 string
    CheckedAt             time.Time
    NextCheckAt           time.Time
    EtagHeader            string
    LastModifiedHeader    string
    ParsingErrorMsg       string
    ParsingErrorCount     int
    ScraperRules          string
    RewriteRules          string
    BlocklistRules        string
    KeeplistRules         string
    // ... 更多配置字段
}
```

#### Entry（条目）
```go
type Entry struct {
    ID          int64
    UserID      int64
    FeedID      int64
    Status      string      // unread, read, removed
    Hash        string      // 去重用
    Title       string
    URL         string
    Content     string
    Author      string
    Date        time.Time
    Starred     bool
    ReadingTime int
    Enclosures  EnclosureList
    Tags        []string
}
```

#### Category（分类）
```go
type Category struct {
    ID     int64
    UserID int64
    Title  string
}
```

### 数据库 Schema 特点

1. **规范化设计**: 遵循第三范式，减少数据冗余
2. **索引优化**: 对常查询字段建立索引
3. **外键约束**: 保证数据完整性
4. **全文搜索**: 使用 PostgreSQL tsvector
5. **时区支持**: 所有时间戳使用 timestamptz

---

## API 设计

### RESTful API 设计原则

#### 1. 端点设计
```
资源命名：复数名词
GET    /v1/feeds           # 列表
POST   /v1/feeds           # 创建
GET    /v1/feeds/{id}      # 详情
PUT    /v1/feeds/{id}      # 更新
DELETE /v1/feeds/{id}      # 删除

子资源：
GET    /v1/feeds/{id}/entries       # Feed 的条目
PUT    /v1/feeds/{id}/refresh       # 刷新 Feed
```

#### 2. 认证机制
```go
// API Key (Header)
X-Auth-Token: your-api-key-here

// Basic Auth
Authorization: Basic base64(username:password)
```

#### 3. 响应格式
```json
// 成功响应
{
  "id": 123,
  "title": "Example Feed",
  "feed_url": "https://example.com/feed"
}

// 错误响应
{
  "error_message": "Feed not found"
}
```

#### 4. 分页
```
GET /v1/entries?limit=100&offset=0&order=published_at&direction=desc
```

#### 5. 过滤
```
GET /v1/entries?status=unread&starred=true
```

### API 实现模式

```go
// api/feed.go 示例
func (h *handler) getFeed(w http.ResponseWriter, r *http.Request) {
    // 1. 提取路径参数
    feedID := request.RouteInt64Param(r, "feedID")
    
    // 2. 认证和授权
    userID := request.UserID(r)
    
    // 3. 业务逻辑
    feed, err := h.store.FeedByID(userID, feedID)
    if err != nil {
        json.ServerError(w, r, err)
        return
    }
    
    // 4. 返回响应
    json.OK(w, r, feed)
}
```

---

## 关键实现细节

### 1. 配置管理

**多源配置支持**:
```go
// 优先级（从高到低）：
1. 命令行参数
2. 环境变量
3. 配置文件
4. 默认值

// 示例环境变量：
DATABASE_URL=postgres://user:pass@host/db
LISTEN_ADDR=0.0.0.0:8080
BASE_PATH=/miniflux
WORKER_POOL_SIZE=5
POLLING_FREQUENCY=60
```

### 2. Feed 刷新调度

**两种调度模式**:

```go
// 1. Round Robin（轮询）
// 按时间顺序依次刷新

// 2. Entry Frequency（基于更新频率）
// 根据 Feed 的更新频率动态调整检查间隔
```

**智能调度特性**:
- HTTP 缓存支持（ETag, Last-Modified）
- 错误退避（失败后延长检查间隔）
- 优先级队列（活跃 Feed 优先）

### 3. 内容清理和安全

**多层安全防护**:

```go
// 1. HTML 清理
sanitizer.Sanitize()
// - 移除危险标签（<script>, <iframe>）
// - 白名单属性
// - URL 清理

// 2. 跟踪器移除
urlcleaner.RemoveTrackingParams()
// - utm_* 参数
// - fbclid
// - 其他跟踪参数

// 3. CSP 头设置
Content-Security-Policy: default-src 'self'
```

### 4. 性能优化

**数据库优化**:
```sql
-- 索引策略
CREATE INDEX idx_entries_user_status ON entries(user_id, status);
CREATE INDEX idx_entries_feed_date ON entries(feed_id, published_at DESC);

-- 查询优化
-- 使用 LIMIT 和 OFFSET 分页
-- 避免 N+1 查询
-- 连接池管理
```

**HTTP 性能**:
- Brotli 压缩
- 静态资源缓存（embed.FS）
- 连接复用
- HTTP/2 支持

### 5. 会话管理

```go
// 基于 Cookie 的会话
// 特点：
- HttpOnly（防止 XSS）
- Secure（HTTPS only）
- SameSite（CSRF 防护）
- 服务端存储（PostgreSQL）
```

### 6. 第三方集成架构

```go
// internal/integration/
// 统一接口设计
type Integration interface {
    PushEntry(entry *model.Entry) error
}

// 每个集成独立实现
// 示例：Notion, Slack, Wallabag, etc.
```

### 7. 错误处理

```go
// 统一错误处理
func handleError(w http.ResponseWriter, r *http.Request, err error) {
    slog.Error("Error occurred", 
        slog.Any("error", err),
        slog.String("url", r.URL.Path),
    )
    
    http.Error(w, "Internal Server Error", 500)
}
```

### 8. 日志记录

```go
// 使用 slog（Go 1.21+）
slog.Info("Starting server", 
    slog.String("address", addr),
    slog.String("version", version.Version),
)

// 支持结构化日志
// 日志级别：debug, info, warn, error
```

---

## 部署方式

### 1. 二进制部署

```bash
# 下载预编译二进制
wget https://github.com/miniflux/v2/releases/download/X.X.X/miniflux-linux-amd64

# 运行
DATABASE_URL=postgres://... ./miniflux
```

### 2. Docker 部署

```yaml
# docker-compose.yml
version: '3'
services:
  miniflux:
    image: miniflux/miniflux:latest
    ports:
      - "80:8080"
    environment:
      - DATABASE_URL=postgres://miniflux:secret@db/miniflux?sslmode=disable
      - RUN_MIGRATIONS=1
      - CREATE_ADMIN=1
      - ADMIN_USERNAME=admin
      - ADMIN_PASSWORD=test123
  db:
    image: postgres:15
    environment:
      - POSTGRES_USER=miniflux
      - POSTGRES_PASSWORD=secret
    volumes:
      - miniflux-db:/var/lib/postgresql/data
volumes:
  miniflux-db:
```

### 3. Systemd 部署

```ini
# /etc/systemd/system/miniflux.service
[Unit]
Description=Miniflux
After=network.target postgresql.service

[Service]
Type=notify
User=miniflux
ExecStart=/usr/bin/miniflux
EnvironmentFile=/etc/miniflux.conf
Restart=always

[Install]
WantedBy=multi-user.target
```

### 4. 包管理器部署

```bash
# Debian/Ubuntu
wget https://github.com/miniflux/v2/releases/download/X.X.X/miniflux_X.X.X_amd64.deb
dpkg -i miniflux_X.X.X_amd64.deb

# RPM
rpm -ivh miniflux-X.X.X-1.0.x86_64.rpm
```

---

## 构建类似 Golang Web 项目的参考

### 1. 项目初始化

```bash
# 创建项目目录
mkdir mywebapp && cd mywebapp

# 初始化 Go 模块
go mod init github.com/yourusername/mywebapp

# 创建基本目录结构
mkdir -p {cmd/server,internal/{api,config,database,http,model,storage},web/{static,templates}}
```

### 2. 推荐的项目结构

```
mywebapp/
├── cmd/
│   └── server/
│       └── main.go              # 程序入口
├── internal/                     # 私有包
│   ├── api/                     # API 处理器
│   ├── config/                  # 配置管理
│   ├── database/                # 数据库层
│   ├── http/                    # HTTP 服务器
│   │   ├── middleware/         # 中间件
│   │   └── router/             # 路由
│   ├── model/                   # 数据模型
│   ├── service/                 # 业务逻辑
│   └── storage/                 # 数据访问层
├── web/                         # Web 资源
│   ├── static/                  # 静态文件
│   └── templates/               # HTML 模板
├── migrations/                  # 数据库迁移
├── scripts/                     # 构建和部署脚本
├── go.mod
├── go.sum
├── Makefile
├── Dockerfile
└── README.md
```

### 3. 核心依赖推荐

#### 3.1 HTTP 路由
```go
// 选项 1: Gorilla Mux（Miniflux 使用）
go get github.com/gorilla/mux

// 选项 2: Chi（轻量级）
go get github.com/go-chi/chi/v5

// 选项 3: 原生标准库（Go 1.22+）
// 支持路径参数：/users/{id}
```

#### 3.2 数据库
```go
// PostgreSQL 驱动
go get github.com/lib/pq

// 或使用 pgx（更现代）
go get github.com/jackc/pgx/v5

// MySQL（如果需要）
go get github.com/go-sql-driver/mysql

// SQLite（如果需要）
go get github.com/mattn/go-sqlite3
```

#### 3.3 配置管理
```go
// 环境变量
go get github.com/kelseyhightower/envconfig

// YAML/TOML 配置
go get github.com/spf13/viper
```

#### 3.4 日志
```go
// 标准库 slog（Go 1.21+）推荐
// 或 zerolog
go get github.com/rs/zerolog
```

#### 3.5 认证
```go
// JWT
go get github.com/golang-jwt/jwt/v5

// OAuth2
go get golang.org/x/oauth2

// Bcrypt（密码哈希）
go get golang.org/x/crypto/bcrypt
```

#### 3.6 验证
```go
// Validator
go get github.com/go-playground/validator/v10
```

#### 3.7 测试
```go
// Testify（断言和 Mock）
go get github.com/stretchr/testify

// HTTP 测试
go get github.com/gavv/httpexpect/v2
```

### 4. 项目骨架代码

#### 4.1 主入口 (cmd/server/main.go)

```go
package main

import (
    "database/sql"
    "log"
    "log/slog"
    "net/http"
    "os"
    
    "github.com/yourusername/mywebapp/internal/config"
    "github.com/yourusername/mywebapp/internal/database"
    "github.com/yourusername/mywebapp/internal/http/router"
    "github.com/yourusername/mywebapp/internal/storage"
)

func main() {
    // 加载配置
    cfg := config.Load()
    
    // 初始化日志
    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
    slog.SetDefault(logger)
    
    // 连接数据库
    db, err := database.Connect(cfg.DatabaseURL)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 运行迁移
    if err := database.Migrate(db); err != nil {
        log.Fatal(err)
    }
    
    // 初始化存储层
    store := storage.NewStorage(db)
    
    // 设置路由
    r := router.New(store)
    
    // 启动服务器
    slog.Info("Starting server", slog.String("address", cfg.ListenAddr))
    if err := http.ListenAndServe(cfg.ListenAddr, r); err != nil {
        log.Fatal(err)
    }
}
```

#### 4.2 配置管理 (internal/config/config.go)

```go
package config

import (
    "os"
    "strconv"
)

type Config struct {
    DatabaseURL string
    ListenAddr  string
    LogLevel    string
    JWTSecret   string
}

func Load() *Config {
    return &Config{
        DatabaseURL: getEnv("DATABASE_URL", "postgres://localhost/myapp?sslmode=disable"),
        ListenAddr:  getEnv("LISTEN_ADDR", ":8080"),
        LogLevel:    getEnv("LOG_LEVEL", "info"),
        JWTSecret:   getEnv("JWT_SECRET", "change-me"),
    }
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if intVal, err := strconv.Atoi(value); err == nil {
            return intVal
        }
    }
    return defaultValue
}
```

#### 4.3 数据库层 (internal/database/database.go)

```go
package database

import (
    "database/sql"
    "fmt"
    
    _ "github.com/lib/pq"
)

func Connect(databaseURL string) (*sql.DB, error) {
    db, err := sql.Open("postgres", databaseURL)
    if err != nil {
        return nil, fmt.Errorf("unable to connect to database: %w", err)
    }
    
    // 设置连接池
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    
    // 测试连接
    if err := db.Ping(); err != nil {
        return nil, fmt.Errorf("unable to ping database: %w", err)
    }
    
    return db, nil
}

func Migrate(db *sql.DB) error {
    // 实现数据库迁移逻辑
    // 可以使用 golang-migrate 或自定义实现
    return nil
}
```

#### 4.4 路由器 (internal/http/router/router.go)

```go
package router

import (
    "net/http"
    
    "github.com/gorilla/mux"
    "github.com/yourusername/mywebapp/internal/api"
    "github.com/yourusername/mywebapp/internal/http/middleware"
    "github.com/yourusername/mywebapp/internal/storage"
)

func New(store *storage.Storage) *mux.Router {
    r := mux.NewRouter()
    
    // 全局中间件
    r.Use(middleware.Logger)
    r.Use(middleware.Recovery)
    r.Use(middleware.CORS)
    
    // 健康检查
    r.HandleFunc("/health", healthCheck).Methods("GET")
    
    // API 路由
    apiRouter := r.PathPrefix("/api/v1").Subrouter()
    apiRouter.Use(middleware.Auth)
    
    handler := api.NewHandler(store)
    handler.Register(apiRouter)
    
    return r
}

func healthCheck(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("OK"))
}
```

#### 4.5 中间件示例 (internal/http/middleware/logger.go)

```go
package middleware

import (
    "log/slog"
    "net/http"
    "time"
)

func Logger(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // 记录响应状态
        wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
        
        next.ServeHTTP(wrapped, r)
        
        slog.Info("HTTP request",
            slog.String("method", r.Method),
            slog.String("path", r.URL.Path),
            slog.Int("status", wrapped.statusCode),
            slog.Duration("duration", time.Since(start)),
        )
    })
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}
```

#### 4.6 存储层示例 (internal/storage/user.go)

```go
package storage

import (
    "database/sql"
    "fmt"
    
    "github.com/yourusername/mywebapp/internal/model"
)

type Storage struct {
    db *sql.DB
}

func NewStorage(db *sql.DB) *Storage {
    return &Storage{db: db}
}

func (s *Storage) CreateUser(user *model.User) error {
    query := `
        INSERT INTO users (username, email, password_hash, created_at)
        VALUES ($1, $2, $3, NOW())
        RETURNING id, created_at
    `
    return s.db.QueryRow(
        query,
        user.Username,
        user.Email,
        user.PasswordHash,
    ).Scan(&user.ID, &user.CreatedAt)
}

func (s *Storage) GetUserByID(id int64) (*model.User, error) {
    user := &model.User{}
    query := `
        SELECT id, username, email, created_at
        FROM users
        WHERE id = $1
    `
    err := s.db.QueryRow(query, id).Scan(
        &user.ID,
        &user.Username,
        &user.Email,
        &user.CreatedAt,
    )
    if err == sql.ErrNoRows {
        return nil, fmt.Errorf("user not found")
    }
    return user, err
}
```

#### 4.7 API 处理器示例 (internal/api/user.go)

```go
package api

import (
    "encoding/json"
    "net/http"
    
    "github.com/gorilla/mux"
    "github.com/yourusername/mywebapp/internal/model"
    "github.com/yourusername/mywebapp/internal/storage"
)

type Handler struct {
    store *storage.Storage
}

func NewHandler(store *storage.Storage) *Handler {
    return &Handler{store: store}
}

func (h *Handler) Register(r *mux.Router) {
    r.HandleFunc("/users", h.createUser).Methods("POST")
    r.HandleFunc("/users/{id}", h.getUser).Methods("GET")
}

func (h *Handler) createUser(w http.ResponseWriter, r *http.Request) {
    var user model.User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    if err := h.store.CreateUser(&user); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(user)
}

func (h *Handler) getUser(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id := vars["id"]
    
    // 实现获取用户逻辑
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]string{"id": id})
}
```

### 5. Makefile 示例

```makefile
.PHONY: build run test lint clean

APP_NAME := mywebapp
GO := go

build:
$(GO) build -o $(APP_NAME) cmd/server/main.go

run:
$(GO) run cmd/server/main.go

test:
$(GO) test -v -race -cover ./...

lint:
golangci-lint run

clean:
rm -f $(APP_NAME)

migrate-up:
migrate -path migrations -database "$(DATABASE_URL)" up

migrate-down:
migrate -path migrations -database "$(DATABASE_URL)" down 1

docker-build:
docker build -t $(APP_NAME):latest .

docker-run:
docker-compose up
```

### 6. Dockerfile 示例

```dockerfile
# 构建阶段
FROM golang:1.24-alpine AS builder

WORKDIR /app

# 复制依赖文件
COPY go.mod go.sum ./
RUN go mod download

# 复制源代码
COPY . .

# 构建二进制
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o mywebapp cmd/server/main.go

# 运行阶段
FROM alpine:latest

RUN apk --no-cache add ca-certificates

WORKDIR /root/

# 从构建阶段复制二进制
COPY --from=builder /app/mywebapp .

EXPOSE 8080

CMD ["./mywebapp"]
```

### 7. 开发最佳实践

#### 7.1 代码组织
- **internal/**: 私有包，不对外暴露
- **cmd/**: 可执行程序入口
- **pkg/**: 可复用的公共库（如果需要）
- 每个包单一职责
- 避免循环依赖

#### 7.2 错误处理
```go
// 使用 errors.Is 和 errors.As
if errors.Is(err, sql.ErrNoRows) {
    return nil, ErrNotFound
}

// 包装错误以添加上下文
return fmt.Errorf("failed to get user: %w", err)
```

#### 7.3 数据库实践
- 使用预处理语句防止 SQL 注入
- 适当使用事务
- 连接池配置
- 索引优化

#### 7.4 安全实践
- 使用 bcrypt 存储密码
- 实现 CSRF 防护
- 设置安全的 HTTP 头
- 输入验证
- 输出转义

#### 7.5 测试
```go
// 单元测试
func TestCreateUser(t *testing.T) {
    // 使用 testify
    assert := assert.New(t)
    
    user := &model.User{Username: "test"}
    err := store.CreateUser(user)
    
    assert.NoError(err)
    assert.NotZero(user.ID)
}

// 集成测试
// 使用 dockertest 启动测试数据库
```

### 8. 部署清单

#### 8.1 环境变量
```bash
# .env.example
DATABASE_URL=postgres://user:pass@localhost/myapp?sslmode=disable
LISTEN_ADDR=:8080
LOG_LEVEL=info
JWT_SECRET=your-secret-key
```

#### 8.2 监控
- 健康检查端点
- Prometheus 指标
- 结构化日志
- 错误追踪（如 Sentry）

#### 8.3 CI/CD
```yaml
# .github/workflows/ci.yml
name: CI
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-go@v4
        with:
          go-version: '1.24'
      - run: go test -v ./...
      - run: golangci-lint run
```

---

## 总结

### Miniflux 的架构优势

1. **简洁性**: 无框架依赖，代码清晰易懂
2. **性能**: 单一二进制，低资源消耗
3. **可维护性**: 清晰的分层架构，职责分明
4. **安全性**: 多层安全防护，注重隐私
5. **可扩展性**: 插件化集成系统
6. **部署简便**: 多种部署方式，配置灵活

### 构建类似项目的关键要点

1. **保持简单**: 不过度设计，从简单开始
2. **分层清晰**: 表示层、业务层、数据层分离
3. **依赖最小**: 只引入必要的依赖
4. **测试完备**: 单元测试 + 集成测试
5. **文档齐全**: 代码文档 + API 文档
6. **安全第一**: 从设计阶段考虑安全
7. **性能优化**: 合理使用缓存和索引
8. **监控完善**: 日志、指标、追踪

### 学习资源

- [Miniflux 源码](https://github.com/miniflux/v2)
- [Go 官方文档](https://golang.org/doc/)
- [Effective Go](https://golang.org/doc/effective_go)
- [Go Database/SQL Tutorial](http://go-database-sql.org/)
- [The Twelve-Factor App](https://12factor.net/)

---

**文档版本**: 1.0  
**创建日期**: 2026-01-04  
**基于项目版本**: Miniflux v2 (commit: latest)
